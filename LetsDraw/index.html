<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>PeerDraw Pro</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#ffffff" id="theme-color-meta">
    
    <!-- Tldraw CSS -->
    <link rel="stylesheet" href="https://esm.sh/tldraw@2.1.0/tldraw.css" />
    
    <!-- QR Code & PeerJS Libraries -->
    <script src="https://unpkg.com/html5-qrcode" type="text/javascript"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.1/build/qrcode.min.js"></script>
    
    <!-- Import Map -->
    <script type="importmap">
    { "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom": "https://esm.sh/react-dom@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "react/jsx-runtime": "https://esm.sh/react@18.2.0/jsx-runtime",
        "tldraw": "https://esm.sh/tldraw@2.1.0?external=react,react-dom",
        "peerjs": "https://esm.sh/peerjs@1.5.2"
    }}
    </script>

    <style>
        :root {
            --primary: #007aff;
            --bg-light: #f2f2f7; --card-light: #ffffff; --text-light: #000000;
            --bg-dark: #131314; --card-dark: #1c1c1e; --text-dark: #ffffff;
            --success: #34c759; --error: #ff3b30;
        }
        body[data-theme="light"] { --bg: var(--bg-light); --card: var(--card-light); --text: var(--text-light); }
        body[data-theme="dark"] { --bg: var(--bg-dark); --card: var(--card-dark); --text: var(--text-dark); }
        
        * { box-sizing: border-box; }

        body, html { margin: 0; padding: 0; width: 100%; height: 100%; background-color: var(--bg); color: var(--text); font-family: system-ui, -apple-system, sans-serif; touch-action: none; overflow: hidden; }

        .layer { position: absolute; inset: 0; transition: transform 0.3s ease, opacity 0.3s ease; }
        .hidden { pointer-events: none; opacity: 0; transform: scale(0.95); }
        
        #dashboard { z-index: 50; padding: 40px 20px; overflow-y: auto; background: var(--bg); }
        .dash-container { max-width: 600px; margin: 0 auto; }
        .header-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px; }
        h1 { font-size: 2.5rem; margin: 0; }
        
        .card { background: var(--card); border-radius: 16px; padding: 20px; margin-bottom: 20px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); }
        .btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        
        button { cursor: pointer; border: none; font-family: inherit; transition: opacity 0.2s; }
        button:active { opacity: 0.7; }
        .btn-primary { background: var(--primary); color: white; padding: 15px; border-radius: 12px; font-weight: 600; font-size: 1rem; width: 100%; }
        .btn-secondary { background: var(--card); border: 1px solid #ccc; color: var(--text); padding: 15px; border-radius: 12px; font-weight: 600; font-size: 1rem; width: 100%; }
        .btn-icon { background: transparent; font-size: 1.5rem; padding: 5px; }
        input { width: 100%; padding: 12px; border-radius: 8px; border: 1px solid #ccc; background: var(--bg); color: var(--text); font-size: 1rem; margin-bottom: 10px; }
        
        .board-item { display: flex; justify-content: space-between; align-items: center; padding: 15px; border-bottom: 1px solid #eee; cursor: pointer; }
        .board-item:last-child { border-bottom: none; }
        .board-item:hover { background-color: rgba(128,128,128,0.1); }

        #workspace { z-index: 10; height: 100vh; width: 100vw; }
        
        .custom-share-panel { display: flex; gap: 8px; align-items: center; pointer-events: all; }
        .status-dot { width: 10px; height: 10px; border-radius: 50%; background: #ccc; }
        .status-dot.connected { background: var(--success); box-shadow: 0 0 8px var(--success); }
        .status-dot.error { background: var(--error); }

        .modal-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 1000; display: flex; align-items: center; justify-content: center; backdrop-filter: blur(5px); }
        .modal-content { background: var(--card); padding: 24px; border-radius: 20px; width: 90%; max-width: 400px; text-align: center; color: var(--text); }
        .color-picker { display: flex; gap: 10px; justify-content: center; margin: 15px 0; }
        .color-opt { width: 30px; height: 30px; border-radius: 50%; cursor: pointer; border: 2px solid transparent; }
        .color-opt.selected { border-color: var(--text); transform: scale(1.1); }

        #toast { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%) translateY(100px); background: #333; color: #fff; padding: 10px 20px; border-radius: 30px; z-index: 2000; transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); font-weight: 500; }
        #toast.visible { transform: translateX(-50%) translateY(0); }
    </style>
</head>
<body data-theme="light">

    <div id="dashboard" class="layer">
        <div class="dash-container">
            <div class="header-row"><h1>PeerDraw Pro</h1><button class="btn-icon" id="theme-toggle">üåì</button></div>
            <div class="card">
                <h3>üë§ Who are you?</h3>
                <input type="text" id="user-name" placeholder="Enter your name" maxlength="15">
                <div class="color-picker" id="color-picker"></div>
            </div>
            <div class="btn-grid">
                <button id="btn-new" class="btn-primary">‚ûï New Board</button>
                <button id="btn-join-scan" class="btn-secondary">üì∑ Scan to Join</button>
            </div>
            <div style="margin-top: 20px; display: flex; gap: 10px;">
                <input type="text" id="manual-join-id" placeholder="Paste Board ID here..." style="margin-bottom:0;">
                <button id="btn-join-manual" class="btn-secondary" style="width: auto;">Join</button>
            </div>
            <h3 style="margin-top: 30px; opacity: 0.6; text-transform: uppercase; font-size: 0.8rem;">Recent Boards</h3>
            <div class="card" id="recent-list" style="padding: 0; overflow: hidden;"><div style="padding: 20px; text-align: center; color: gray;">No recent boards</div></div>
        </div>
    </div>

    <div id="workspace" class="layer hidden"></div>

    <div id="scan-modal" class="hidden modal-backdrop">
        <div class="modal-content">
            <h3>Scan QR Code</h3>
            <div id="qr-reader" style="width: 100%"></div>
            <button class="btn-secondary" onclick="App.ui.closeModals()" style="margin-top: 15px">Close</button>
        </div>
    </div>

    <div id="share-modal" class="hidden modal-backdrop">
        <div class="modal-content">
            <h3 class="modal-title">Invite Collaborators</h3>
            <canvas id="qr-canvas" style="display: block; margin: 0 auto 15px; border-radius: 8px;"></canvas>
            <input type="text" id="share-link" readonly onclick="this.select()">
            <button class="btn-primary" id="btn-copy-link">Copy Link</button>
            <button class="btn-secondary" onclick="App.ui.closeModals()" style="margin-top: 10px">Close</button>
        </div>
    </div>
    <div id="toast">Notification</div>

    <script type="module">
        import React, { useState, useEffect, useCallback, useRef } from 'react';
        import { createRoot } from 'react-dom/client';
        import { Tldraw, createTLStore, defaultShapeUtils, uniqueId } from 'tldraw';
        import { Peer } from 'peerjs';

        function throttle(func, limit) {
            let timeout;
            let lastArgs;
            let lastContext;
            let lastRan;

            return function() {
                lastContext = this;
                lastArgs = arguments;

                if (!lastRan) {
                    func.apply(lastContext, lastArgs);
                    lastRan = Date.now();
                } else {
                    clearTimeout(timeout);
                    timeout = setTimeout(function() {
                        if ((Date.now() - lastRan) >= limit) {
                            func.apply(lastContext, lastArgs);
                            lastRan = Date.now();
                        }
                    }, limit - (Date.now() - lastRan));
                }
            };
        }

        const DB = {
            dbName: 'PeerDrawDB_v2',
            async init() {
                return new Promise((resolve, reject) => {
                    const req = indexedDB.open(this.dbName, 1);
                    req.onupgradeneeded = e => e.target.result.createObjectStore('boards', { keyPath: 'id' });
                    req.onsuccess = e => resolve(e.target.result);
                    req.onerror = e => reject(e);
                });
            },
            async save(id, snapshot) {
                const db = await this.init();
                const tx = db.transaction('boards', 'readwrite');
                tx.objectStore('boards').put({ id, snapshot, updatedAt: Date.now() });
            },
            async getAll() {
                const db = await this.init();
                return new Promise(resolve => {
                    const req = db.transaction('boards', 'readonly').objectStore('boards').getAll();
                    req.onsuccess = () => resolve(req.result.sort((a,b) => b.updatedAt - a.updatedAt));
                });
            }
        };

        const USER_COLORS = ['#FF0000', '#00FF00', '#0000FF', '#FFA500', '#800080', '#00FFFF'];
        const UserPrefs = {
            get: () => JSON.parse(localStorage.getItem('peerdraw-user') || '{"name":"Guest","color":"#FF0000"}'),
            set: (p) => localStorage.setItem('peerdraw-user', JSON.stringify(p))
        };

        const uiOverrides = {
            actions(editor, actions) {
                actions['toggle-fullscreen'] = {
                    id: 'toggle-fullscreen',
                    label: 'Toggle Fullscreen',
                    readonlyOk: true,
                    onSelect() {
                        if (!document.fullscreenElement) {
                            document.documentElement.requestFullscreen().catch(err => console.error(err));
                        } else if (document.exitFullscreen) {
                            document.exitFullscreen();
                        }
                    },
                };
                return actions;
            },
            menu(editor, menu, { actions }) {
                const fileMenu = menu.find(item => item.id === 'menu' && item.type === 'group');
                if (fileMenu) {
                    fileMenu.children.unshift(
                        { id: 'toggle-fullscreen-item', type: 'item', action: actions['toggle-fullscreen'], icon: 'maximize-2' },
                        { id: 'custom-separator', type: 'separator' }
                    );
                }
                return menu;
            },
        };

        function CollaborativeEditor({ boardId, isHost, initialSnapshot, onClose }) {
            const [store] = useState(() => {
                const s = createTLStore({ shapeUtils: defaultShapeUtils });
                if (initialSnapshot) s.loadSnapshot(initialSnapshot);
                return s;
            });
            const [connections, setConnections] = useState(new Map());
            const [status, setStatus] = useState(isHost ? 'online' : 'connecting');
            const user = UserPrefs.get();
            const connectionsRef = useRef(connections);

            useEffect(() => {
                connectionsRef.current = connections;
            }, [connections]);

            useEffect(() => {
                const newPeer = new Peer(isHost ? boardId : undefined);
                newPeer.on('open', (id) => {
                    if (!isHost) {
                        const conn = newPeer.connect(boardId);
                        setupConnection(conn);
                    }
                    setStatus('connected');
                });
                newPeer.on('connection', (conn) => setupConnection(conn));
                newPeer.on('error', (err) => { console.error(err); setStatus('error'); App.ui.toast(err.type, 'error'); });
                return () => newPeer.destroy();
            }, []);

            const setupConnection = (conn) => {
                conn.on('open', () => {
                    setConnections(prev => new Map(prev).set(conn.peer, conn));
                    if (isHost) {
                        const snap = store.getSnapshot();
                        conn.send(JSON.stringify({ type: 'init', snapshot: snap }));
                    }
                });
                conn.on('data', (data) => handleRemoteData(data));
                conn.on('close', () => setConnections(prev => { const n = new Map(prev); n.delete(conn.peer); return n; }));
            };

            const handleRemoteData = (raw) => {
                const msg = JSON.parse(raw);
                if (msg.type === 'init') {
                    store.loadSnapshot(msg.snapshot);
                } else if (msg.type === 'changes') {
                    store.mergeRemoteChanges(() => {
                        const { added, updated, removed } = msg.changes;
                        if (added) Object.values(added).forEach(record => store.put([record]));
                        
                        // THE DEFINITIVE FIX: 'updated' provides a [before, after] tuple.
                        // We must use the 'after' value (the second element).
                        if (updated) Object.values(updated).forEach(([before, after]) => store.put([after]));

                        if (removed) Object.values(removed).forEach(record => store.remove([record.id]));
                    });
                }
            };

            useEffect(() => {
                // Define which record types should be synced across clients.
                // We exclude instance-specific states like camera, tool selection, etc.
                const SYNCED_TYPES = new Set(['shape', 'asset', 'page', 'instance_presence']);

                const filterChanges = (changes) => {
                    const filtered = { added: {}, updated: {}, removed: {} };

                    for (const id in changes.added) {
                        const record = changes.added[id];
                        if (SYNCED_TYPES.has(record.typeName)) {
                            filtered.added[id] = record;
                        }
                    }

                    for (const id in changes.updated) {
                        const [before, after] = changes.updated[id];
                        if (SYNCED_TYPES.has(after.typeName)) {
                            // Add user's name and color to their presence state before sending
                            if (after.typeName === 'instance_presence') {
                                after.userName = user.name;
                                after.color = user.color;
                            }
                            filtered.updated[id] = [before, after];
                        }
                    }
                    
                    for (const id in changes.removed) {
                        const record = changes.removed[id];
                        if (SYNCED_TYPES.has(record.typeName)) {
                            filtered.removed[id] = record;
                        }
                    }
                    return filtered;
                };

                const broadcast = (changes) => {
                    const filteredChanges = filterChanges(changes);

                    // Don't broadcast if there are no relevant changes
                    if (Object.keys(filteredChanges.added).length === 0 &&
                        Object.keys(filteredChanges.updated).length === 0 &&
                        Object.keys(filteredChanges.removed).length === 0) {
                        return;
                    }
                    
                    const payload = JSON.stringify({ type: 'changes', changes: filteredChanges });
                    connectionsRef.current.forEach(conn => { if (conn.open) conn.send(payload); });
                };

                const handleUpdate = throttle((update) => {
                    if (update.source !== 'user') return;
                    broadcast(update.changes);
                    if (isHost) DB.save(boardId, store.getSnapshot());
                }, 16);

                const cleanup = store.listen(handleUpdate);
                return () => cleanup();
            }, [store, isHost, boardId, user.name, user.color]);

            const handleAssetUpload = useCallback(async (file) => {
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.readAsDataURL(file);
                });
            }, []);

            const SharePanel = () => React.createElement('div', { className: 'custom-share-panel' }, 
                React.createElement('div', { className: `status-dot ${status === 'connected' ? 'connected' : ''}`, title: status }),
                isHost ? React.createElement('button', { className: 'btn-primary', style: { padding: '8px 16px', fontSize: '14px', width: 'auto' }, onClick: () => App.ui.showShareModal(boardId) }, 'Invite') : null,
                React.createElement('button', { className: 'btn-secondary', style: { padding: '8px', width: 'auto' }, onClick: onClose, title: 'Home' }, 'üè†')
            );
            
            return React.createElement('div', { style: { position: 'fixed', inset: 0 } },
                React.createElement(Tldraw, {
                    store: store,
                    overrides: uiOverrides,
                    components: { SharePanel },
                    onMount: (editor) => {
                        editor.user.updateUserPreferences({ name: user.name, color: user.color });
                        if(window.innerWidth < 600) editor.updateInstanceState({ isGridMode: false });
                    },
                    onAssetUpload: handleAssetUpload
                })
            );
        }

        const App = {
            init() {
                this.setupTheme();
                this.setupDashboard();
                this.renderRecent();
            },
            ui: {
                toast(msg, type='info') {
                    const t = document.getElementById('toast');
                    t.textContent = msg;
                    t.style.backgroundColor = type === 'error' ? 'var(--error)' : '#333';
                    t.classList.add('visible');
                    setTimeout(() => t.classList.remove('visible'), 3000);
                },
                showShareModal(id) {
                    const url = `${window.location.origin}${window.location.pathname}?join=${id}`;
                    document.getElementById('share-link').value = url;
                    QRCode.toCanvas(document.getElementById('qr-canvas'), url, { width: 200, margin: 1 });
                    document.getElementById('share-modal').classList.remove('hidden');
                    document.getElementById('btn-copy-link').onclick = () => { navigator.clipboard.writeText(url); this.toast('Link Copied!', 'success'); };
                },
                closeModals() {
                    document.querySelectorAll('.modal-backdrop').forEach(el => el.classList.add('hidden'));
                    if (App.scanner && App.scanner.isScanning) App.scanner.stop().catch(e=>console.log(e));
                }
            },
            setupTheme() {
                const theme = localStorage.getItem('theme') || 'light';
                document.body.dataset.theme = theme;
                document.getElementById('theme-toggle').onclick = () => {
                    const newTheme = document.body.dataset.theme === 'light' ? 'dark' : 'light';
                    document.body.dataset.theme = newTheme;
                    localStorage.setItem('theme', newTheme);
                };
            },
            setupDashboard() {
                const prefs = UserPrefs.get();
                document.getElementById('user-name').value = prefs.name;
                const picker = document.getElementById('color-picker');
                picker.innerHTML = '';
                USER_COLORS.forEach(c => {
                    const div = document.createElement('div');
                    div.className = `color-opt ${prefs.color === c ? 'selected' : ''}`;
                    div.style.backgroundColor = c;
                    div.onclick = () => {
                        document.querySelectorAll('.color-opt').forEach(el => el.classList.remove('selected'));
                        div.classList.add('selected');
                        UserPrefs.set({ ...UserPrefs.get(), color: c });
                    };
                    picker.appendChild(div);
                });
                document.getElementById('user-name').onchange = (e) => UserPrefs.set({ ...UserPrefs.get(), name: e.target.value });
                document.getElementById('btn-new').onclick = () => this.startBoard(uniqueId(), true);
                document.getElementById('btn-join-manual').onclick = () => {
                    const id = document.getElementById('manual-join-id').value.trim();
                    if(id) this.startBoard(id, false);
                };
                document.getElementById('btn-join-scan').onclick = () => {
                    document.getElementById('scan-modal').classList.remove('hidden');
                    this.scanner = new Html5Qrcode("qr-reader");
                    this.scanner.start({ facingMode: "environment" }, { fps: 10, qrbox: {width: 250, height: 250} }, (decoded) => {
                        try {
                            const url = new URL(decoded);
                            const joinId = url.searchParams.get('join');
                            if(joinId) { App.ui.closeModals(); this.startBoard(joinId, false); }
                        } catch(e) { console.error(e); }
                    }, (errorMessage) => {}).catch(err => { App.ui.toast('Camera error', 'error'); });
                };
                const params = new URLSearchParams(window.location.search);
                if (params.get('join')) { this.startBoard(params.get('join'), false); window.history.replaceState({}, '', window.location.pathname); }
            },
            async renderRecent() {
                const list = document.getElementById('recent-list');
                const boards = await DB.getAll();
                if (boards.length === 0) { list.innerHTML = `<div style="padding: 20px; text-align: center; color: gray;">No recent boards</div>`; return; }
                list.innerHTML = '';
                boards.forEach(b => {
                    const el = document.createElement('div');
                    el.className = 'board-item';
                    el.innerHTML = `<span>üìÖ ${new Date(b.updatedAt).toLocaleDateString()} (${b.id.slice(0,5)})</span> <span>‚û°Ô∏è</span>`;
                    el.onclick = () => this.startBoard(b.id, true, b.snapshot);
                    list.appendChild(el);
                });
            },
            startBoard(id, isHost, snapshot=null) {
                document.getElementById('dashboard').classList.add('hidden');
                document.getElementById('workspace').classList.remove('hidden');
                const root = createRoot(document.getElementById('workspace'));
                root.render(React.createElement(CollaborativeEditor, { 
                    boardId: id, 
                    isHost: isHost, 
                    initialSnapshot: snapshot,
                    onClose: () => {
                        root.unmount();
                        document.getElementById('workspace').innerHTML = '';
                        document.getElementById('workspace').classList.add('hidden');
                        document.getElementById('dashboard').classList.remove('hidden');
                        this.renderRecent();
                    }
                }));
            }
        };
        window.App = App;
        App.init();
    </script>
</body>
</html>